# ADVANCED CODE DOCUMENTATION: LINEAR ALGEBRA & STATISTICS CALCULATOR

This document provides a comprehensive technical breakdown of every function used in this project. The calculator is built on a custom **Fraction** engine to ensure exact results (where mathematically possible) and handles both complex Linear Algebra and common Statistical operations.

---

## 1. THE FOUNDATION: Fraction.h
The `Fraction` class handles all arithmetic. By using two `long long` values (numerator and denominator), we avoid the "floating point drift" (e.g., 0.1 + 0.2 = 0.30000000004) common in standard programming.

### `reduce()`
- **Purpose**: Simplifies a fraction to its lowest terms (e.g., 4/8 becomes 1/2).
- **Logic**: It calculates the Greatest Common Divisor (GCD) of the numerator and denominator using `std::gcd` and divides both by it. It also ensures the denominator is always positive.

### `fromDouble(double value)`
- **Purpose**: Converts a decimal number into the closest possible fraction.
- **Logic**: Uses a **Continued Fraction Expansion** algorithm. This is much more accurate than simple rounding, as it can recognize decimals like 0.3333... as 1/3 exactly.

### Arithmetic Operators (`+`, `-`, `*`, `/`)
- **Logic**: Implements standard fraction rules:
  - Addition: `(a/b) + (c/d) = (ad + bc) / bd`
  - Multiplication: `(a/b) * (c/d) = (ac) / (bd)`
- All results are automatically passed through `reduce()` after every operation.

---

## 2. LINEAR ALGEBRA: Matrix.cpp / Matrix.h
The `Matrix` class uses a `std::vector<std::vector<Fraction>>` to store data.

### `operator+` and `operator-` (Addition/Subtraction)
- **Logic**: Iterates through every element `(i, j)` and performs fraction addition/subtraction on corresponding cells.
- **Constraint**: Throws an error if matrix dimensions don't match.

### `operator*` (Multiplication)
- **Logic**: Standard dot product: `Result[i][j] = Sum(A[i][k] * B[k][j])`.
- **Complexity**: O(n³) operations. Each operation is a fraction multiplication and addition.

### `transpose()`
- **Logic**: Switches rows with columns. `Result[j][i] = Original[i][j]`.

### `ref()` (Row Echelon Form)
- **Logic**: Uses **Gaussian Elimination**.
- **Steps**:
  1. Find a pivot (non-zero element) in the current column.
  2. Swap rows if necessary to bring the pivot to the diagonal.
  3. Use row operations (`R2 = R2 - (pivot2/pivot1)*R1`) to clear all elements below the pivot.

### `rref()` (Reduced Row Echelon Form)
- **Logic**: Extends the `ref()` logic.
- **Steps**: After achieving `ref()`, it performs "back-substitution" to clear elements *above* the pivots and then divides each row by its pivot value to make all pivots equal to `1`.
- **Utility**: Used as the backbone for solving linear equations, finding Rank, and checking Linear Independence.

### `determinant()`
- **Logic**: For 1x1 and 2x2, it uses fixed formulas. For larger matrices, it uses **LU Decomposition-style elimination** (converting to triangular form via `ref()`).
- **Formula**: The determinant of a triangular matrix is the product of its diagonal elements. We also track how many row swaps were made (each swap flips the sign).

### `inverse()`
- **Logic**: Uses the **Gauss-Jordan Method**.
- **Steps**: Creates an augmented matrix `[A | I]` where `I` is the identity matrix. It performs `rref()` on the whole thing. If it's successful, the right side of the augmented matrix becomes `A⁻¹`.

### `rank()`
- **Logic**: Counts the number of non-zero rows in the `rref()` version of the matrix. This represents the number of linearly independent rows/columns.

### `trace()`
- **Logic**: Calculates the sum of all elements on the main diagonal (`A[0][0] + A[1][1] + ...`).

### `eigenvalues()`
- **Logic**:
  - **2x2**: Solves the characteristic quadratic equation `λ² - trace(A)λ + det(A) = 0` using the quadratic formula.
  - **Larger**: Uses the **QR Algorithm**. It repeatedly decomposes `A = QR` and sets `A = RQ`. Over several iterations (30), the matrix converges to a form where eigenvalues are on the diagonal.

### `getRowVector(i)` and `getColVector(j)`
- **Logic**: Extracts a specific row or column as a single list (`std::vector`) to be used in statistical calculations.

---

## 3. STATISTICS: Statistics.h
A utility class designed to work with both standard vectors and matrix-extracted data.

### `calculateMean()`
- **Logic**: Sums all elements in the set and divides by the total count `n`.
- **Formula**: `Σx / n`. Returns a `Fraction`.

### `calculateVariance()`
- **Logic**: Calculates **Sample Variance** (Bessel's correction).
- **Steps**:
  1. Find the Mean.
  2. Calculate the squared difference of each number from the mean: `(x - Mean)²`.
  3. Sum those squares and divide by `n - 1`.
- **Formula**: `Σ(x - Mean)² / (n - 1)`.

### `calculateStandardDeviation()`
- **Logic**: Simply the square root of the Variance.
- **Note**: Since the square root of a fraction can be irrational, this function returns a `double` for precision, but the interface shows it alongside the fractional variance.

---

## 4. UI & LOGIC: main.cpp

### `inputMatrix()`
- **Logic**: A robust input handler that accepts integers or fractions (e.g., `5/3`). It parses the string input and converts it into `Fraction` objects before placing them in the matrix.

### `linearAlgebraMenu()` and `statisticalMenu()`
- **Logic**: These functions isolate the logic for each toolset.
- **Integration**: The `statisticalMenu` allows users to select which "Source Matrix" to pull data from, then choose a specific Row or Column to analyze, bridging the gap between Algebra and Statistics.

### `main()`
- **Logic**: The top-level controller that manages the clear screen, header printing, and routing the user to the appropriate sub-menu.
