/*
 * EXTRACTED FUNCTIONS: LINEAR AND STATISTICAL OPERATIONS
 */

// ==========================================
// STATISTICAL OPERATIONS (from Statistics.h)
// ==========================================

static double calculateMean(const std::vector<double> &data) {
  if (data.empty())
    return 0.0;
  double sum = 0.0;
  for (double val : data) {
    sum += val;
  }
  return sum / static_cast<double>(data.size());
}

static double calculateVariance(const std::vector<double> &data) {
  if (data.size() < 2)
    return 0.0;
  double mean = calculateMean(data);
  double sumSqDiff = 0.0;
  for (double val : data) {
    double diff = val - mean;
    sumSqDiff += diff * diff;
  }
  return sumSqDiff / static_cast<double>(data.size() - 1);
}

static double calculateStandardDeviation(const std::vector<double> &data) {
  return std::sqrt(calculateVariance(data));
}


// ==========================================
// LINEAR OPERATIONS (from Matrix.cpp)
// ==========================================

// Matrix Addition
Matrix Matrix::operator+(const Matrix &other) const {
  if (rows != other.rows || cols != other.cols) {
    throw std::invalid_argument("Matrix dimensions must match for addition");
  }
  Matrix result(rows, cols);
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      result.data[i][j] = data[i][j] + other.data[i][j];
    }
  }
  return result;
}

// Matrix Subtraction
Matrix Matrix::operator-(const Matrix &other) const {
  if (rows != other.rows || cols != other.cols) {
    throw std::invalid_argument("Matrix dimensions must match for subtraction");
  }
  Matrix result(rows, cols);
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      result.data[i][j] = data[i][j] - other.data[i][j];
    }
  }
  return result;
}

// Matrix Multiplication
Matrix Matrix::operator*(const Matrix &other) const {
  if (cols != other.rows) {
    throw std::invalid_argument("Invalid dimensions for matrix multiplication");
  }
  Matrix result(rows, other.cols);
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < other.cols; j++) {
      double sum = 0.0;
      for (int k = 0; k < cols; k++) {
        sum += data[i][k] * other.data[k][j];
      }
      result.data[i][j] = sum;
    }
  }
  return result;
}

// Scalar Multiplication
Matrix Matrix::operator*(double scalar) const {
  Matrix result(rows, cols);
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      result.data[i][j] = data[i][j] * scalar;
    }
  }
  return result;
}

// Matrix Transposition
Matrix Matrix::transpose() const {
  Matrix result(cols, rows);
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      result.data[j][i] = data[i][j];
    }
  }
  return result;
}

// Reduced Row Echelon Form (RREF)
Matrix Matrix::rref() const {
  Matrix result = *this;
  int lead = 0;
  for (int r = 0; r < rows && lead < cols; r++) {
    int i = r;
    while (i < rows && std::abs(result.data[i][lead]) < EPSILON) {
      i++;
    }
    if (i == rows) {
      lead++;
      r--;
      continue;
    }
    if (i != r) {
      result.swapRows(r, i);
    }
    double pivot = result.data[r][lead];
    if (std::abs(pivot) > EPSILON) {
      result.multiplyRow(r, 1.0 / pivot);
    }
    for (int i = 0; i < rows; i++) {
      if (i != r) {
        double factor = result.data[i][lead];
        result.addMultipleOfRow(i, r, -factor);
      }
    }
    lead++;
  }
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      if (std::abs(result.data[i][j]) < EPSILON)
        result.data[i][j] = 0.0;
    }
  }
  return result;
}

// Determinant
double Matrix::determinant() const {
  if (!isSquare()) {
    throw std::invalid_argument(
        "Determinant is only defined for square matrices");
  }
  if (rows == 1)
    return data[0][0];
  if (rows == 2)
    return data[0][0] * data[1][1] - data[0][1] * data[1][0];
  double det = 0.0;
  for (int j = 0; j < cols; j++) {
    Matrix submatrix = getSubmatrix(0, j);
    double cofactor = data[0][j] * submatrix.determinant();
    det += (j % 2 == 0) ? cofactor : -cofactor;
  }
  return det;
}

// Trace
double Matrix::trace() const {
  if (!isSquare()) {
    throw std::invalid_argument("Trace is only defined for square matrices");
  }
  double tr = 0.0;
  for (int i = 0; i < rows; i++) {
    tr += data[i][i];
  }
  return tr;
}

// Matrix Inverse
Matrix Matrix::inverse() const {
  if (!isSquare()) {
    throw std::invalid_argument("Only square matrices can be inverted");
  }
  double det = determinant();
  if (std::abs(det) < EPSILON) {
    throw std::runtime_error("Matrix is singular and cannot be inverted");
  }
  Matrix augmented(rows, 2 * cols);
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      augmented.data[i][j] = data[i][j];
      augmented.data[i][j + cols] = (i == j) ? 1.0 : 0.0;
    }
  }
  augmented = augmented.rref();
  Matrix result(rows, cols);
  for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
      result.data[i][j] = augmented.data[i][j + cols];
    }
  }
  return result;
}

// Gram-Schmidt Process
Matrix Matrix::gramSchmidt() const {
  Matrix result(rows, cols);
  for (int j = 0; j < cols; j++) {
    std::vector<double> v(rows);
    for (int i = 0; i < rows; i++)
      v[i] = data[i][j];
    for (int k = 0; k < j; k++) {
      double dotVU = 0.0, dotUU = 0.0;
      for (int i = 0; i < rows; i++) {
        dotVU += v[i] * result.data[i][k];
        dotUU += result.data[i][k] * result.data[i][k];
      }
      if (dotUU > EPSILON) {
        double proj = dotVU / dotUU;
        for (int i = 0; i < rows; i++)
          v[i] -= proj * result.data[i][k];
      }
    }
    double normSq = 0.0;
    for (int i = 0; i < rows; i++)
      normSq += v[i] * v[i];
    if (normSq > EPSILON) {
      double norm = std::sqrt(normSq);
      for (int i = 0; i < rows; i++)
        result.data[i][j] = v[i] / norm;
    }
  }
  return result;
}

