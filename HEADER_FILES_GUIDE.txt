================================================================================
        COMPLETE CODE EXPLANATION - C++ MATRIX CALCULATOR
        Line-by-Line Guide with Header Files Explained
================================================================================

This document explains EVERY line of code so you can fully understand
how the matrix calculator works, including detailed explanations of all
header files used in the project.

================================================================================
SECTION 1: UNDERSTANDING HEADER FILES
================================================================================

Before diving into the code, let's understand what header files are and why
every file in this project includes them.

--------------------------------------------------------------------------------
WHAT ARE HEADER FILES?
--------------------------------------------------------------------------------

Header files (.h) are files that contain:
1. Function DECLARATIONS (what functions exist and their signatures)
2. Class DECLARATIONS (what classes exist and their structure)
3. Constant definitions
4. Type definitions
5. Template definitions

IMPORTANT CONCEPTS:

**Declaration vs Definition:**
- DECLARATION tells the compiler a name exists (in .h files)
- DEFINITION provides the actual implementation (in .cpp files)

**Why separate .h and .cpp?**
- .h files are small and quick to compile
- Multiple .cpp files can #include the same .h file
- Changes to .cpp don't require recompiling everything

**#include Directive:**
- Copies the entire contents of the header file into your code
- Happens BEFORE compilation (preprocessing step)
- Two forms:
  * `#include <filename>` - System/library headers
  * `#include "filename"` - Your own headers (same directory)

--------------------------------------------------------------------------------
STANDARD LIBRARY HEADERS USED IN THIS PROJECT
--------------------------------------------------------------------------------

### 1. <iostream> - Input/Output Stream
**Purpose:** Console input and output
**What it provides:**
- `std::cout` - Print to console
- `std::cin` - Read from keyboard
- `std::endl` - End line and flush buffer
- `<<` operator for output
- `>>` operator for input

**Example Usage:**
```cpp
#include <iostream>
std::cout << "Hello World" << std::endl;
int x;
std::cin >> x;
```

**Used in:** main.cpp (for user interface)

---

### 2. <vector> - Dynamic Arrays
**Purpose:** Resizable array container
**What it provides:**
- `std::vector<T>` - Template class for dynamic arrays
- `.push_back()` - Add element to end
- `.size()` - Get number of elements
- `.resize()` - Change size
- `[]` operator for access

**Example Usage:**
```cpp
#include <vector>
std::vector<int> numbers;  // Empty vector
numbers.push_back(5);      // Add 5
numbers[0] = 10;           // Change to 10
```

**Used in:** Matrix.h, Matrix.cpp (for storing matrix data)
**Why?** Matrices can be different sizes, so we use vector<vector<Fraction>>

---

### 3. <string> - String Class
**Purpose:** Text manipulation
**What it provides:**
- `std::string` - Class for text
- `.find()` - Search for substring
- `.substr()` - Extract substring
- `+` operator for concatenation
- `.length()` / `.size()` - Get length

**Example Usage:**
```cpp
#include <string>
std::string name = "Matrix";
std::string full = name + " Calculator";  // "Matrix Calculator"
size_t pos = full.find("Calc");  // Returns 7
```

**Used in:** Fraction.h, main.cpp (for parsing input, creating output)
**Why?** We need to parse fraction input like "3/4" and create formatted output

---

### 4. <cmath> - Mathematical Functions
**Purpose:** Advanced math operations
**What it provides:**
- `std::sqrt()` - Square root
- `std::abs()` - Absolute value
- `std::pow()` - Power function
- Trigonometric functions (sin, cos, tan)

**Example Usage:**
```cpp
#include <cmath>
double x = std::sqrt(16.0);    // 4.0
double y = std::abs(-5.0);      // 5.0
```

**Used in:** Fraction.h, Matrix.cpp (for square roots in normalization)
**Why?** Gram-Schmidt orthogonalization requires normalizing vectors (dividing by length)

---

### 5. <numeric> - Numeric Algorithms
**Purpose:** Numeric operations
**What it provides:**
- `std::gcd()` - Greatest Common Divisor
- `std::lcm()` - Least Common Multiple
- `std::accumulate()` - Sum of range
- `std::iota()` - Fill with sequence

**Example Usage:**
```cpp
#include <numeric>
long long g = std::gcd(12, 8);  // Returns 4
long long l = std::lcm(12, 8);  // Returns 24
```

**Used in:** Fraction.h (for reducing fractions)
**Why?** To simplify fractions: 6/8 = 3/4 by dividing by gcd(6,8)=2

---

### 6. <iomanip> - Input/Output Manipulation
**Purpose:** Formatting output
**What it provides:**
- `std::setw(n)` - Set field width
-  `std::setprecision(n)` - Set decimal precision
- `std::fixed` - Fixed-point notation
- `std::scientific` - Scientific notation

**Example Usage:**
```cpp
#include <iomanip>
#include <iostream>
std::cout << std::setw(10) << 42;  // "        42" (padded)
```

**Used in:** Matrix.h, Matrix.cpp (for aligned matrix display)
**Why?** Makes matrices print nicely:
```
[      1/2        1/3 ]
[      1/4        1/5 ]
```

---

### 7. <stdexcept> - Standard Exceptions
**Purpose:** Error handling
**What it provides:**
- `std::invalid_argument` - Bad argument exception
- `std::runtime_error` - Runtime error exception
- `std::out_of_range` - Index out of bounds
- `std::logic_error` - Logic error

**Example Usage:**
```cpp
#include <stdexcept>
if (denominator == 0) {
    throw std::runtime_error("Division by zero");
}
```

**Used in:** Matrix.h, Matrix.cpp (for validation)
**Why?** Catch errors like:
- Matrix dimensions don't match for addition
- Trying to invert a singular matrix
- Accessing invalid matrix index

---

### 8. <algorithm> - Algorithms
**Purpose:** Common algorithms
**What it provides:**
- `std::swap()` - Swap two values
- `std::min()` / `std::max()` - Min/max values
- `std::sort()` - Sort a range
- `std::find()` - Find element

**Example Usage:**
```cpp
#include <algorithm>
int a = 5, b = 10;
std::swap(a, b);  // Now a=10, b=5
int smaller = std::min(a, b);  // 5
```

**Used in:** Matrix.h, Matrix.cpp (for row swapping, finding min/max)
**Why?** Row operations in Gaussian elimination require swapping rows

---

### 9. <limits> - Numeric Limits
**Purpose:** Limits of numeric types
**What it provides:**
- `std::numeric_limits<T>::max()` - Maximum value
- `std::numeric_limits<T>::min()` - Minimum value
- `std::numeric_limits<T>::infinity()` - Infinity
- `std::numeric_limits<streamsize>::max()` - Max stream size

**Example Usage:**
```cpp
#include <limits>
int biggest = std::numeric_limits<int>::max();  // 2147483647
```

**Used in:** main.cpp (for clearing input buffer)
**Why?** When input fails, we ignore everything until newline:
```cpp
cin.ignore(numeric_limits<streamsize>::max(), '\n');
```

---

### 10. <utility> - Utility Components
**Purpose:** General utilities
**What it provides:**
- `std::pair<T1, T2>` - Pair of values
- `std::make_pair()` - Create pair
- `std::move()` - Move semantics
- `std::swap()` - Swap values

**Example Usage:**
```cpp
#include <utility>
std::pair<int, std::string> entry{1, "First"};
auto [id, name] = entry;  // Structured binding (C++17)
```

**Used in:** Matrix.h (implicitly, for eigenvalues return type)
**Why?** Eigenvalues function returns both eigenvalues AND eigenvectors:
```cpp
std::pair<std::vector<Fraction>, Matrix> eigenvalues() const;
```

--------------------------------------------------------------------------------
CUSTOM HEADER FILES IN THIS PROJECT
--------------------------------------------------------------------------------

### Fraction.h - Rational Number Class
**Location:** d:\Programming\proj_scratch\Fraction.h
**Purpose:** Define the Fraction class for exact arithmetic
**Why custom?** Standard library has no fraction class!

**What it declares:**
```cpp
class Fraction {
private:
    long long num;  // Numerator
    long long den;  // Denominator
    void reduce();  // Helper to simplify
public:
    Fraction(long long n, long long d);  // Constructor
    Fraction operator+(const Fraction& f) const;  // Addition
    // ... other operators ...
    std::string toString() const;  // Convert to string
    double toDouble() const;  // Convert to decimal
};
```

**Included by:**
- Matrix.h (Matrix uses Fraction for elements)
- main.cpp (indirectly through Matrix.h)

**Include syntax:**
```cpp
#include "Fraction.h"  // Quotes, not angle brackets!
```

---

### Matrix.h - Matrix Class
**Location:** d:\Programming\proj_scratch\Matrix.h
**Purpose:** Define the Matrix class for linear algebra
**Why custom?** We're building our own matrix library!

**What it declares:**
```cpp
const int MAX_SIZE = 5;  // Size limit

class Matrix {
private:
    std::vector<std::vector<Fraction>> data;
    int rows, cols;
public:
    Matrix(int r, int c);  // Constructor
    Matrix operator+(const Matrix& m) const;  // Addition
    Fraction determinant() const;  // Determinant
    Matrix inverse() const;  // Inverse
    // ... many more operations ...
};
```

**Included by:**
- Matrix.cpp (implementation file)
- main.cpp (user interface)

**Include syntax:**
```cpp
#include "Matrix.h"  // Automatically includes Fraction.h too
```

**Important:** Matrix.h itself includes Fraction.h, so when you #include "Matrix.h",
you get both! This is called "transitive inclusion".

--------------------------------------------------------------------------------
INCLUDE DEPENDENCY CHAIN
--------------------------------------------------------------------------------

Let's trace what gets included when you compile main.cpp:

```
main.cpp
  ↓ includes "Matrix.h"
      ↓ includes "Fraction.h"
          ↓ includes <iostream>
          ↓ includes <string>
          ↓ includes <cmath>
          ↓ includes <numeric>
      ↓ includes <vector>
      ↓ includes <iostream> (already included)
      ↓ includes <iomanip>
      ↓ includes <stdexcept>
      ↓ includes <algorithm>
  ↓ includes <iostream> (already included)
  ↓ includes <limits>
```

**Note:** Headers are only processed once thanks to "include guards" (explained below).

--------------------------------------------------------------------------------
INCLUDE GUARDS - PREVENTING DOUBLE INCLUSION
--------------------------------------------------------------------------------

Every header file in this project starts with:

```cpp
#ifndef FRACTION_H
#define FRACTION_H
// ... content ...
#endif
```

**What this does:**
1. First time: FRACTION_H not defined → process content → define FRACTION_H
2. Second time: FRACTION_H already defined → skip everything
3. Result: Contents only included once, even if #include appears multiple times

**Why needed?**
Without guards:
```cpp
// File A.h
struct Point { int x, y; };

// File B.h
#include "A.h"

// File C.h
#include "A.h"
#include "B.h"  // ERROR! Point defined twice
```

With guards, Point is only defined once, no matter how many times A.h is included.

**Naming convention:**
- Filename: Fraction.h → Guard: FRACTION_H
- Filename: Matrix.h → Guard: MATRIX_H
- Use ALL_CAPS with underscores

--------------------------------------------------------------------------------
COMPILATION ORDER AND HEADERS
--------------------------------------------------------------------------------

When you compile:
```bash
g++ -o main_full.exe main.cpp Matrix.cpp -std=c++17
```

**Step 1: Preprocessing**
- Compiler reads main.cpp
- Processes all #include directives (copies header contents)
- Creates one huge file with all code
- Repeats for Matrix.cpp

**Step 2: Compilation**
- Compiles preprocessed main.cpp → main.o
- Compiles preprocessed Matrix.cpp → Matrix.o
- Each .o file contains machine code

**Step 3: Linking**
- Combines main.o and Matrix.o
- Resolves function calls between files
- Creates main_full.exe

**Why .cpp and .h are separate:**
- Headers declare what exists
- .cpp files define how it works
- Multiple .cpp files can share one .h
- Changing .cpp doesn't require recompiling files that include the .h

--------------------------------------------------------------------------------
HEADER FILE BEST PRACTICES USED IN THIS PROJECT
--------------------------------------------------------------------------------

1. **Always use include guards**
   ✓ Every .h file has #ifndef/#define/#endif

2. **Include what you use**
   ✓ Each file includes only needed headers
   
3. **Use forward declarations when possible**
   ✗ We don't use this (kept simple for education)

4. **Minimize includes in headers**
   ✓ Fraction.h only includes what it needs
   ✓ Matrix.h includes Fraction.h and standard library

5. **Use quotes for local headers, angle brackets for system**
   ✓ `#include "Matrix.h"`  (our file)
   ✓ `#include <vector>`     (system library)

6. **Put implementation in .cpp, declarations in .h**
   ✓ Matrix.h has declarations
   ✓ Matrix.cpp has implementations
   Exception: Inline functions (getRows(), isSquare()) defined in .h

================================================================================
FILE 1: Fraction.h - The Rational Number Class
================================================================================

Now that you understand headers, let's examine the code!

[... rest of the original detailed code explanation continues ...]
